// <auto-generated/> Public attribute & source generator implementation for DKNet.EfCore.DtoGenerator.
// Consumers reference this project/package as an Analyzer. Keep logic cohesive here.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DKNet.EfCore.DtoGenerator;

#nullable enable

/// <summary>
/// Incremental source generator for DTOs. Generates properties (init-only) for each public instance
/// readable property of the entity (adds 'required' for non-nullable reference types).
/// No mapping helper methods are generated (entity to DTO mapping can be handled externally e.g. via Mapster Adapt).
/// </summary>
[Generator]
[System.Diagnostics.CodeAnalysis.SuppressMessage("MicrosoftCodeAnalysisCorrectness", "RS1041:This compiler extension should not be implemented in an assembly with target framework", Justification = "Targeting .NET 9+ only")]
public sealed class DtoGenerator : IIncrementalGenerator
{
    #region Constants

    private const string AttributeShortName = "GenerateDto";
    private const string AttributeFullName = "GenerateDtoAttribute";
    private const string ExcludeParameterName = "Exclude";
    private const string DiagnosticId = "DKDTOGEN001";
    private const string DiagnosticCategory = "DKNet.EfCore.DtoGenerator";

    #endregion

    #region Initialization

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var targets = CreateSyntaxProvider(context);
        var compilation = context.CompilationProvider.Combine(targets.Collect());
        RegisterSourceGeneration(context, compilation);
    }

    private static IncrementalValuesProvider<Target> CreateSyntaxProvider(IncrementalGeneratorInitializationContext context)
    {
        return context.SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => IsTypeDeclarationWithAttributes(node),
                static (ctx, _) => ExtractGenerationTarget(ctx))
            .Where(static t => t is not null)!;
    }

    private static void RegisterSourceGeneration(
        IncrementalGeneratorInitializationContext context,
        IncrementalValueProvider<(Compilation Left, System.Collections.Immutable.ImmutableArray<Target> Right)> compilation)
    {
        context.RegisterSourceOutput(compilation, static (spc, pair) =>
        {
            var (compilation, targets) = pair;
            foreach (var target in targets)
            {
                if (target is null) continue;

                try
                {
                    GenerateDtoSource(spc, compilation, target);
                }
                catch (Exception ex)
                {
                    ReportGenerationError(spc, target.DtoSymbol, ex.Message);
                }
            }
        });
    }

    #endregion

    #region Attribute Detection & Parsing

    private static bool IsTypeDeclarationWithAttributes(SyntaxNode node)
    {
        return node is TypeDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static Target? ExtractGenerationTarget(GeneratorSyntaxContext ctx)
    {
        if (ctx.Node is not TypeDeclarationSyntax typeDeclaration) 
            return null;

        foreach (var attributeList in typeDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var target = TryExtractTargetFromAttribute(ctx, typeDeclaration, attribute);
                if (target is not null)
                    return target;
            }
        }

        return null;
    }

    private static Target? TryExtractTargetFromAttribute(
        GeneratorSyntaxContext ctx,
        TypeDeclarationSyntax typeDeclaration,
        AttributeSyntax attribute)
    {
        if (!IsGenerateDtoAttribute(attribute))
            return null;

        if (attribute.ArgumentList?.Arguments.Count < 1)
            return null;

        var entitySymbol = ExtractEntityTypeFromAttribute(ctx, attribute);
        if (entitySymbol is null)
            return null;

        var dtoSymbol = ctx.SemanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol;
        if (dtoSymbol is null)
            return null;

        var excludedProperties = ExtractExcludedPropertiesFromAttribute(ctx, attribute);
        return new Target
        {
            DtoSymbol = dtoSymbol,
            EntitySymbol = entitySymbol,
            ExcludedProperties = excludedProperties
        };
    }

    private static bool IsGenerateDtoAttribute(AttributeSyntax attribute)
    {
        var shortName = ExtractAttributeShortName(attribute);
        return shortName is AttributeShortName or AttributeFullName;
    }

    private static string? ExtractAttributeShortName(AttributeSyntax attribute)
    {
        return attribute.Name switch
        {
            IdentifierNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };
    }

    #endregion

    #region Entity Type Extraction

    private static INamedTypeSymbol? ExtractEntityTypeFromAttribute(GeneratorSyntaxContext ctx, AttributeSyntax attribute)
    {
        var firstArg = attribute.ArgumentList!.Arguments[0].Expression;
        
        return firstArg switch
        {
            TypeOfExpressionSyntax typeOfExpression => ExtractEntityFromTypeOfExpression(ctx, typeOfExpression),
            LiteralExpressionSyntax literal when literal.IsKind(SyntaxKind.StringLiteralExpression)
                => ResolveEntityByName(ctx.SemanticModel.Compilation, literal.Token.ValueText),
            _ => null
        };
    }

    private static INamedTypeSymbol? ExtractEntityFromTypeOfExpression(GeneratorSyntaxContext ctx, TypeOfExpressionSyntax typeOfExpression)
    {
        var entitySymbol = ctx.SemanticModel.GetTypeInfo(typeOfExpression.Type).Type as INamedTypeSymbol;
        
        // If resolution failed, try by name as fallback
        if (entitySymbol is null || entitySymbol is IErrorTypeSymbol)
        {
            if (typeOfExpression.Type is IdentifierNameSyntax identifierName)
            {
                return ResolveEntityByName(ctx.SemanticModel.Compilation, identifierName.Identifier.Text);
            }
        }
        
        return entitySymbol;
    }

    private static INamedTypeSymbol? ResolveEntityByName(Compilation compilation, string entityName)
    {
        var matches = FindTypeSymbolsByName(compilation, entityName);
        
        return matches.Count switch
        {
            1 => matches[0],
            > 1 => null, // Ambiguous - skip generation
            _ => null    // Not found
        };
    }

    private static List<INamedTypeSymbol> FindTypeSymbolsByName(Compilation compilation, string typeName)
    {
        return compilation
            .GetSymbolsWithName(name => name.Equals(typeName, StringComparison.Ordinal), SymbolFilter.Type)
            .OfType<INamedTypeSymbol>()
            .Where(symbol => symbol.TypeKind is TypeKind.Class or TypeKind.Struct)
            .ToList();
    }

    #endregion

    #region Excluded Properties Extraction

    private static HashSet<string> ExtractExcludedPropertiesFromAttribute(GeneratorSyntaxContext ctx, AttributeSyntax attribute)
    {
        foreach (var arg in attribute.ArgumentList!.Arguments.Skip(1))
        {
            if (arg.NameEquals?.Name.Identifier.Text == ExcludeParameterName)
            {
                return ExtractExcludedPropertiesFromExpression(ctx, arg.Expression);
            }
        }

        return new HashSet<string>();
    }

    private static HashSet<string> ExtractExcludedPropertiesFromExpression(GeneratorSyntaxContext ctx, ExpressionSyntax? expression)
    {
        return expression switch
        {
            ImplicitArrayCreationExpressionSyntax implicitArray
                => ExtractStringLiteralsFromInitializer(implicitArray.Initializer),
            ArrayCreationExpressionSyntax { Initializer: not null } explicitArray
                => ExtractStringLiteralsFromInitializer(explicitArray.Initializer),
            CollectionExpressionSyntax collectionExpr
                => ExtractStringLiteralsFromCollectionExpression(ctx, collectionExpr),
            _ => new HashSet<string>()
        };
    }

    private static HashSet<string> ExtractStringLiteralsFromInitializer(InitializerExpressionSyntax initializer)
    {
        var result = new HashSet<string>();
        
        foreach (var expression in initializer.Expressions)
        {
            if (expression is LiteralExpressionSyntax literal && literal.Token.Value is string propertyName)
            {
                result.Add(propertyName);
            }
        }
        
        return result;
    }

    private static HashSet<string> ExtractStringLiteralsFromCollectionExpression(
        GeneratorSyntaxContext ctx,
        CollectionExpressionSyntax collectionExpression)
    {
        var excludedProperties = new HashSet<string>();

        foreach (var element in collectionExpression.Elements)
        {
            if (element is ExpressionElementSyntax { Expression: var expr })
            {
                // Try to get the constant value - this handles both string literals and nameof() expressions
                var constantValue = ctx.SemanticModel.GetConstantValue(expr);
                if (constantValue.HasValue && constantValue.Value is string propertyName)
                {
                    excludedProperties.Add(propertyName);
                }
            }
        }

        return excludedProperties;
    }

    #endregion

    #region DTO Source Generation

    private static void GenerateDtoSource(SourceProductionContext context, Compilation compilation, Target target)
    {
        var dtoMetadata = ExtractDtoMetadata(target);
        var entityProperties = GetEntityProperties(target.EntitySymbol);
        
        // Debug logging: Report property details
        var diagnosticMessage = $"DTO {target.DtoSymbol.Name}: Found {entityProperties.Count} properties from entity {target.EntitySymbol.ToDisplayString()}";
        
        if (entityProperties.Count == 0)
        {
            var diagnostic = new DiagnosticDescriptor(
                id: "DKDTOGEN002",
                title: "No properties found for entity",
                messageFormat: diagnosticMessage + ". This may indicate the entity type wasn't resolved correctly.",
                category: DiagnosticCategory,
                DiagnosticSeverity.Warning,
                isEnabledByDefault: true);
            
            context.ReportDiagnostic(
                Diagnostic.Create(diagnostic, Location.None));
        }
        
        var includedProperties = FilterIncludedProperties(entityProperties, target.ExcludedProperties);
        
        // Additional logging for property filtering
        if (includedProperties.Count < entityProperties.Count)
        {
            var excludedCount = entityProperties.Count - includedProperties.Count;
            var info = new DiagnosticDescriptor(
                id: "DKDTOGEN003",
                title: "Properties excluded from DTO",
                messageFormat: $"DTO {{0}}: {excludedCount} properties excluded. Excluded: {string.Join(", ", target.ExcludedProperties)}",
                category: DiagnosticCategory,
                DiagnosticSeverity.Info,
                isEnabledByDefault: true);
            
            context.ReportDiagnostic(
                Diagnostic.Create(info, Location.None, target.DtoSymbol.Name));
        }
        
        var requiredNamespaces = CollectRequiredNamespaces(includedProperties, dtoMetadata.Namespace);
        var typeDisplayFormat = CreateTypeDisplayFormat();
        var sourceCode = BuildDtoSourceCode(dtoMetadata, includedProperties, requiredNamespaces, typeDisplayFormat);
        
        // Create a unique, stable filename using the full qualified name of the DTO
        var fileName = CreateUniqueFileName(target.DtoSymbol);
        context.AddSource(fileName, sourceCode);
    }

    private static string CreateUniqueFileName(INamedTypeSymbol dtoSymbol)
    {
        // Use just the DTO's simple name for a cleaner filename
        // The namespace scope in the generated code ensures uniqueness
        return $"{dtoSymbol.Name}.g.cs";
    }

    private static DtoMetadata ExtractDtoMetadata(Target target)
    {
        var dtoSymbol = target.DtoSymbol;
        var entitySymbol = target.EntitySymbol;
        
        // Only consider properties defined in user source code (not generated files)
        // to avoid treating previously generated properties as "existing"
        var existingProperties = new HashSet<string>(
            dtoSymbol.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(p => !IsFromGeneratedCode(p))
                .Select(p => p.Name));

        var namespaceName = dtoSymbol.ContainingNamespace is { IsGlobalNamespace: false } 
            ? dtoSymbol.ContainingNamespace.ToDisplayString() 
            : null;
        
        var typeKind = DetermineTypeKind(dtoSymbol);
        var entityDisplayName = entitySymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        
        return new DtoMetadata(
            dtoSymbol.Name,
            namespaceName,
            typeKind,
            entityDisplayName,
            existingProperties);
    }
    
    private static bool IsFromGeneratedCode(IPropertySymbol property)
    {
        // If the property has no syntax references, it's likely from metadata/generated code
        if (property.DeclaringSyntaxReferences.Length == 0)
            return true;
            
        // Check ALL syntax references - if ANY come from generated code, consider it generated
        foreach (var syntaxRef in property.DeclaringSyntaxReferences)
        {
            var filePath = syntaxRef.SyntaxTree.FilePath;
            
            // Simply check if it ends with .g.cs (the standard convention for generated files)
            // This is the most reliable way to detect our own generated output
            if (filePath.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase))
            {
                return true;
            }
        }
        
        return false;
    }

    private static string DetermineTypeKind(INamedTypeSymbol dtoSymbol)
    {
        if (!dtoSymbol.IsRecord)
            return "partial class";

        return dtoSymbol.TypeKind == TypeKind.Struct
            ? "partial record struct"
            : "partial record";
    }

    #endregion

    #region Property Analysis

    private static List<IPropertySymbol> GetEntityProperties(INamedTypeSymbol entitySymbol)
    {
        var properties = new List<IPropertySymbol>();
        var seenPropertyNames = new HashSet<string>();

        // Walk up the inheritance chain to collect all properties
        var currentType = entitySymbol;
        while (currentType is not null)
        {
            // Get properties declared on this type level
            var declaredProperties = currentType.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(IsValidEntityProperty);

            // Add properties that haven't been overridden (avoid duplicates)
            foreach (var property in declaredProperties)
            {
                if (seenPropertyNames.Add(property.Name))
                {
                    properties.Add(property);
                }
            }

            // Move to base type
            currentType = currentType.BaseType;

            // Stop at System.Object or System.ValueType
            if (currentType?.SpecialType is SpecialType.System_Object or SpecialType.System_ValueType)
                break;
        }

        return properties;
    }

    private static bool IsValidEntityProperty(IPropertySymbol property)
    {
        return !property.IsStatic && 
               property.DeclaredAccessibility == Accessibility.Public && 
               property.GetMethod is not null && 
               property.GetMethod.DeclaredAccessibility == Accessibility.Public &&
               property.Parameters.Length == 0;
    }

    private static List<IPropertySymbol> FilterIncludedProperties(
        List<IPropertySymbol> entityProperties,
        HashSet<string> excludedProperties)
    {
        if (excludedProperties.Count == 0)
            return entityProperties;

        return entityProperties
            .Where(p => !excludedProperties.Contains(p.Name))
            .ToList();
    }

    private static PropertyInfo AnalyzeProperty(IPropertySymbol property, SymbolDisplayFormat typeFormat)
    {
        var typeName = GetPropertyTypeName(property, typeFormat);
        var isNonNullableString = IsNonNullableString(property);
        var isCollection = IsCollectionType(property);

        return new PropertyInfo(
            property.Name,
            typeName,
            isNonNullableString,
            isCollection,
            property.NullableAnnotation);
    }

    private static string GetPropertyTypeName(IPropertySymbol property, SymbolDisplayFormat typeFormat)
    {
        var type = property.Type;

        // Build the complete type name manually to avoid any global:: prefixes
        var typeName = BuildCleanTypeName(type);

        // Ensure nullable reference types have the ? suffix
        if (type.IsReferenceType &&
            property.NullableAnnotation == NullableAnnotation.Annotated &&
            !typeName.EndsWith("?"))
        {
            typeName += "?";
        }

        return typeName;
    }

    private static string BuildCleanTypeName(ITypeSymbol type)
    {
        // Handle special types (int, string, etc.) using C# keywords
        if (type.SpecialType != SpecialType.None)
        {
            return type.SpecialType switch
            {
                SpecialType.System_Object => "object",
                SpecialType.System_Boolean => "bool",
                SpecialType.System_Char => "char",
                SpecialType.System_SByte => "sbyte",
                SpecialType.System_Byte => "byte",
                SpecialType.System_Int16 => "short",
                SpecialType.System_UInt16 => "ushort",
                SpecialType.System_Int32 => "int",
                SpecialType.System_UInt32 => "uint",
                SpecialType.System_Int64 => "long",
                SpecialType.System_UInt64 => "ulong",
                SpecialType.System_Decimal => "decimal",
                SpecialType.System_Single => "float",
                SpecialType.System_Double => "double",
                SpecialType.System_String => "string",
                SpecialType.System_Void => "void",
                _ => type.Name
            };
        }

        // Handle array types
        if (type is IArrayTypeSymbol arrayType)
        {
            var elementTypeName = BuildCleanTypeName(arrayType.ElementType);
            return $"{elementTypeName}[]";
        }

        // Handle nullable value types
        if (type is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T } nullable)
        {
            var underlyingTypeName = BuildCleanTypeName(nullable.TypeArguments[0]);
            return $"{underlyingTypeName}?";
        }

        // Handle generic types (like List<T>, IEnumerable<T>, etc.)
        if (type is INamedTypeSymbol namedType && namedType.TypeArguments.Length > 0)
        {
            var genericName = namedType.Name;
            var typeArgs = string.Join(", ", namedType.TypeArguments.Select(BuildCleanTypeName));
            return $"{genericName}<{typeArgs}>";
        }

        // For non-generic types, just use the simple name (no namespace, no global::)
        return type.Name;
    }

    private static bool IsNonNullableString(IPropertySymbol property)
    {
        return property.Type.SpecialType == SpecialType.System_String &&
               property.NullableAnnotation != NullableAnnotation.Annotated;
    }

    private static bool IsCollectionType(IPropertySymbol property)
    {
        if (property.Type is IArrayTypeSymbol)
            return true;

        if (property.Type is not INamedTypeSymbol namedType)
            return false;

        var fullyQualifiedName = namedType.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        return IsKnownCollectionInterface(fullyQualifiedName);
    }

    private static bool IsKnownCollectionInterface(string fullyQualifiedName)
    {
        return fullyQualifiedName.StartsWith("global::System.Collections.Generic.List<") ||
               fullyQualifiedName.StartsWith("global::System.Collections.Generic.IList<") ||
               fullyQualifiedName.StartsWith("global::System.Collections.Generic.ICollection<") ||
               fullyQualifiedName.StartsWith("global::System.Collections.Generic.IEnumerable<");
    }

    #endregion

    #region Namespace Collection

    private static HashSet<string> CollectRequiredNamespaces(List<IPropertySymbol> properties, string? dtoNamespace)
    {
        var namespaces = new HashSet<string>();
        
        foreach (var property in properties)
        {
            CollectNamespacesFromType(property.Type, namespaces, dtoNamespace);
        }
        
        return namespaces;
    }

    private static void CollectNamespacesFromType(ITypeSymbol type, HashSet<string> namespaces, string? dtoNamespace)
    {
        // Skip special types (int, string, etc.)
        if (type.SpecialType != SpecialType.None)
            return;

        // Handle nullable value types
        if (type is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T } nullable)
        {
            CollectNamespacesFromType(nullable.TypeArguments[0], namespaces, dtoNamespace);
            return;
        }

        // Add namespace if it's not the DTO's own namespace and not global
        if (type.ContainingNamespace is { IsGlobalNamespace: false } ns)
        {
            var nsString = ns.ToDisplayString();

            // Skip System namespace (except System.Collections.Generic)
            // Always include System.Collections.Generic
            // Always include namespaces different from the DTO's namespace
            if (nsString == "System.Collections.Generic" ||
                (nsString != dtoNamespace && nsString != "System"))
            {
                namespaces.Add(nsString);
            }
        }

        // Recursively handle generic type arguments
        if (type is INamedTypeSymbol namedType)
        {
            foreach (var typeArg in namedType.TypeArguments)
            {
                CollectNamespacesFromType(typeArg, namespaces, dtoNamespace);
            }
        }

        // Handle array element types
        if (type is IArrayTypeSymbol arrayType)
        {
            CollectNamespacesFromType(arrayType.ElementType, namespaces, dtoNamespace);
        }
    }

    private static SymbolDisplayFormat CreateTypeDisplayFormat()
    {
        return new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameOnly,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes);
    }

    #endregion

    #region Code Building

    private static string BuildDtoSourceCode(
        DtoMetadata metadata,
        List<IPropertySymbol> properties,
        HashSet<string> namespaces,
        SymbolDisplayFormat typeFormat)
    {
        var builder = new StringBuilder();
        
        AppendFileHeader(builder);
        AppendUsingDirectives(builder, namespaces);
        AppendNamespaceDeclaration(builder, metadata.Namespace);
        AppendDtoClassDeclaration(builder, metadata);
        AppendDtoProperties(builder, properties, metadata.ExistingProperties, typeFormat);
        AppendClassClosing(builder);
        
        return builder.ToString();
    }

    private static void AppendFileHeader(StringBuilder builder)
    {
        builder.AppendLine("// <auto-generated/> Generated by DKNet.EfCore.DtoGenerator");
        builder.AppendLine("#nullable enable");
    }

    private static void AppendUsingDirectives(StringBuilder builder, HashSet<string> namespaces)
    {
        if (namespaces.Count == 0)
            return;

        foreach (var namespaceName in namespaces.OrderBy(n => n))
        {
            builder.Append("using ").Append(namespaceName).AppendLine(";");
        }
        
        builder.AppendLine();
    }

    private static void AppendNamespaceDeclaration(StringBuilder builder, string? namespaceName)
    {
        if (namespaceName is not null)
        {
            builder.Append("namespace ").Append(namespaceName).AppendLine(";");
            builder.AppendLine();
        }
    }

    private static void AppendDtoClassDeclaration(StringBuilder builder, DtoMetadata metadata)
    {
        builder.AppendLine("/// <summary>");
        builder.Append("/// Generated DTO for entity ").Append(metadata.EntityDisplayName).AppendLine(".");
        builder.AppendLine("/// </summary>");
        builder.Append("public ").Append(metadata.TypeKind).Append(' ').AppendLine(metadata.Name);
        builder.AppendLine("{");
    }

    private static void AppendDtoProperties(
        StringBuilder builder,
        List<IPropertySymbol> properties,
        HashSet<string> existingProperties,
        SymbolDisplayFormat typeFormat)
    {
        foreach (var property in properties)
        {
            if (existingProperties.Contains(property.Name))
                continue;
                
            var propertyInfo = AnalyzeProperty(property, typeFormat);
            AppendPropertyDeclaration(builder, propertyInfo);
        }
    }

    private static void AppendPropertyDeclaration(StringBuilder builder, PropertyInfo propertyInfo)
    {
        builder.Append("    public ");
        
        if (propertyInfo.IsNonNullableString)
            builder.Append("required ");
            
        builder.Append(propertyInfo.TypeName)
               .Append(' ')
               .Append(propertyInfo.Name)
               .Append(" { get; init; }");
        
        // Initialize non-nullable collections with empty collection
        if (propertyInfo.IsCollection && propertyInfo.NullableAnnotation != NullableAnnotation.Annotated)
        {
            builder.Append(" = [];");
        }
        
        builder.AppendLine();
    }

    // private static void AppendDtoConstructor(
    //     StringBuilder builder,
    //     string dtoName,
    //     List<IPropertySymbol> properties,
    //     SymbolDisplayFormat typeFormat)
    // {
    //     // Constructor generation is disabled - DTOs can use object initializers or primary constructors
    //     return;
    // }

    // private static void AppendConstructorDocumentation(StringBuilder builder)
    // {
    //     // Not used - constructors are not generated
    // }
    //
    // private static void AppendConstructorSignature(
    //     StringBuilder builder,
    //     string dtoName,
    //     List<IPropertySymbol> properties,
    //     SymbolDisplayFormat typeFormat)
    // {
    //     // Not used - constructors are not generated
    // }
    //
    // private static void AppendConstructorBody(StringBuilder builder, List<IPropertySymbol> properties)
    // {
    //     // Not used - constructors are not generated
    // }

    private static void AppendClassClosing(StringBuilder builder)
    {
        builder.AppendLine("}");
    }

    private static string CreateParameterName(string propertyName)
    {
        if (string.IsNullOrEmpty(propertyName))
            return propertyName;

        var paramName = char.ToLowerInvariant(propertyName[0]) + propertyName.Substring(1);
        
        // Escape C# keywords
        if (SyntaxFacts.GetKeywordKind(paramName) != SyntaxKind.None)
            paramName = "@" + paramName;
            
        return paramName;
    }

    #endregion

    #region Diagnostics

    private static void ReportGenerationError(SourceProductionContext context, INamedTypeSymbol dtoSymbol, string message)
    {
        var descriptor = new DiagnosticDescriptor(
            id: DiagnosticId,
            title: "DTO generation warning",
            messageFormat: "{0}: {1}",
            category: DiagnosticCategory,
            DiagnosticSeverity.Warning,
            isEnabledByDefault: true);

        context.ReportDiagnostic(
            Diagnostic.Create(descriptor, Location.None, dtoSymbol.ToDisplayString(), message));
    }

    #endregion

    #region Data Models

    private sealed record Target
    {
        public INamedTypeSymbol DtoSymbol { get; set; } = null!;
        public INamedTypeSymbol EntitySymbol { get; set; } = null!;
        public HashSet<string> ExcludedProperties { get; set; } = new();

        // Use string-based comparison for stability across compilations
        // SymbolEqualityComparer can give inconsistent results with incremental compilation
        public bool Equals(Target? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;

            // Compare using ToDisplayString for stable comparison across compilations
            var dtoName1 = DtoSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var dtoName2 = other.DtoSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (dtoName1 != dtoName2)
                return false;

            var entityName1 = EntitySymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var entityName2 = other.EntitySymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (entityName1 != entityName2)
                return false;

            // Compare excluded properties count and content
            if (ExcludedProperties.Count != other.ExcludedProperties.Count)
                return false;

            return ExcludedProperties.SetEquals(other.ExcludedProperties);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hash = 17;
                
                // Use string-based hash for stability
                var dtoName = DtoSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var entityName = EntitySymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                
                hash = hash * 31 + StringComparer.Ordinal.GetHashCode(dtoName);
                hash = hash * 31 + StringComparer.Ordinal.GetHashCode(entityName);

                // Hash excluded properties in a stable order
                foreach (var prop in ExcludedProperties.OrderBy(p => p, StringComparer.Ordinal))
                {
                    hash = hash * 31 + StringComparer.Ordinal.GetHashCode(prop);
                }

                return hash;
            }
        }
    }

    private sealed class DtoMetadata
    {
        public string Name { get; }
        public string? Namespace { get; }
        public string TypeKind { get; }
        public string EntityDisplayName { get; }
        public HashSet<string> ExistingProperties { get; }

        public DtoMetadata(
            string name,
            string? namespaceName,
            string typeKind,
            string entityDisplayName,
            HashSet<string> existingProperties)
        {
            Name = name;
            Namespace = namespaceName;
            TypeKind = typeKind;
            EntityDisplayName = entityDisplayName;
            ExistingProperties = existingProperties;
        }
    }

    private sealed class PropertyInfo
    {
        public string Name { get; }
        public string TypeName { get; }
        public bool IsNonNullableString { get; }
        public bool IsCollection { get; }
        public NullableAnnotation NullableAnnotation { get; }

        public PropertyInfo(
            string name,
            string typeName,
            bool isNonNullableString,
            bool isCollection,
            NullableAnnotation nullableAnnotation)
        {
            Name = name;
            TypeName = typeName;
            IsNonNullableString = isNonNullableString;
            IsCollection = isCollection;
            NullableAnnotation = nullableAnnotation;
        }
    }

    #endregion
}

