// <auto-generated/> Public attribute & source generator implementation for DKNet.EfCore.DtoGenerator.
// Consumers reference this project/package as an Analyzer. Keep logic cohesive here.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;

namespace DKNet.EfCore.DtoGenerator;

#nullable enable

/// <summary>
/// Incremental source generator for DTOs. Generates properties (init-only) for each public instance
/// readable property of the entity (adds 'required' for non-nullable reference types).
/// No mapping helper methods are generated (entity to DTO mapping can be handled externally e.g. via Mapster Adapt).
/// </summary>
[Generator]
[System.Diagnostics.CodeAnalysis.SuppressMessage("MicrosoftCodeAnalysisCorrectness", "RS1041:This compiler extension should not be implemented in an assembly with target framework", Justification = "Targeting .NET 9+ only")]
public sealed class DtoGenerator : IIncrementalGenerator
{
    #region Constants

    private const string AttributeShortName = "GenerateDto";
    private const string AttributeFullName = "GenerateDtoAttribute";
    private const string ExcludeParameterName = "Exclude";
    private const string IncludeParameterName = "Include";
    private const string DiagnosticId = "DKDTOGEN001";
    private const string DiagnosticCategory = "DKNet.EfCore.DtoGenerator";

    #endregion

    #region Initialization

    /// <summary>
    /// Initializes the incremental generator. Registers the syntax provider and source output.
    /// </summary>
    /// <param name="context">The generator initialization context.</param>
    /// <example>
    /// // Called by the Roslyn infrastructure
    /// generator.Initialize(context);
    /// </example>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var targets = CreateSyntaxProvider(context);
        var compilation = context.CompilationProvider.Combine(targets.Collect());
        RegisterSourceGeneration(context, compilation);
    }

    /// <summary>
    /// Creates a syntax provider that finds all type declarations with the [GenerateDto] attribute.
    /// </summary>
    /// <param name="context">The generator initialization context.</param>
    /// <returns>An incremental values provider of Target records.</returns>
    private static IncrementalValuesProvider<Target> CreateSyntaxProvider(IncrementalGeneratorInitializationContext context)
    {
        return context.SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => IsTypeDeclarationWithAttributes(node),
                static (ctx, _) => ExtractGenerationTarget(ctx))
            .Where(static t => t is not null)!;
    }

    /// <summary>
    /// Registers the source generation step for all collected targets.
    /// </summary>
    /// <param name="context">The generator initialization context.</param>
    /// <param name="compilation">The compilation and collected targets.</param>
    private static void RegisterSourceGeneration(
        IncrementalGeneratorInitializationContext context,
        IncrementalValueProvider<(Compilation Left, System.Collections.Immutable.ImmutableArray<Target> Right)> compilation)
    {
        // Combine compilation with analyzer config options to access global exclusions
        var compilationWithOptions = compilation.Combine(context.AnalyzerConfigOptionsProvider);
        
        context.RegisterSourceOutput(compilationWithOptions, static (spc, pair) =>
        {
            var ((compilation, targets), optionsProvider) = pair;
            
            // Extract global exclusions from analyzer config
            var globalExclusions = ExtractGlobalExclusionsFromConfig(optionsProvider);
            
            foreach (var target in targets)
            {
                if (target is null) continue;

                try
                {
                    GenerateDtoSource(spc, compilation, target, globalExclusions);
                }
                catch (Exception ex)
                {
                    ReportGenerationError(spc, target.DtoSymbol, ex.Message);
                }
            }
        });
    }
    
    /// <summary>
    /// Extracts global exclusion list from analyzer configuration options.
    /// </summary>
    /// <param name="optionsProvider">The analyzer config options provider.</param>
    /// <returns>A set of globally excluded property names.</returns>
    private static HashSet<string> ExtractGlobalExclusionsFromConfig(AnalyzerConfigOptionsProvider optionsProvider)
    {
        var globalExclusions = new HashSet<string>();
        
        // Try to read from global options
        var globalOptions = optionsProvider.GlobalOptions;
        if (globalOptions.TryGetValue("build_property.DtoGeneratorExclusions", out var exclusionsValue) &&
            !string.IsNullOrWhiteSpace(exclusionsValue))
        {
            // Split by comma or semicolon
            var properties = exclusionsValue.Split(new[] { ',', ';' }, StringSplitOptions.RemoveEmptyEntries);
            foreach (var prop in properties)
            {
                var trimmed = prop.Trim();
                if (!string.IsNullOrEmpty(trimmed))
                {
                    globalExclusions.Add(trimmed);
                }
            }
        }
        
        return globalExclusions;
    }

    #endregion

    #region Attribute Detection & Parsing

    /// <summary>
    /// Determines if a syntax node is a type declaration with attributes.
    /// </summary>
    /// <param name="node">The syntax node.</param>
    /// <returns>True if the node is a type declaration with attributes.</returns>
    private static bool IsTypeDeclarationWithAttributes(SyntaxNode node)
    {
        return node is TypeDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    /// <summary>
    /// Extracts a generation target from a type declaration's attributes, if present.
    /// </summary>
    /// <param name="ctx">The generator syntax context.</param>
    /// <returns>A Target if found, otherwise null.</returns>
    private static Target? ExtractGenerationTarget(GeneratorSyntaxContext ctx)
    {
        if (ctx.Node is not TypeDeclarationSyntax typeDeclaration) 
            return null;

        foreach (var attributeList in typeDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var target = TryExtractTargetFromAttribute(ctx, typeDeclaration, attribute);
                if (target is not null)
                    return target;
            }
        }

        return null;
    }

    /// <summary>
    /// Attempts to extract a Target from a [GenerateDto] attribute.
    /// </summary>
    /// <param name="ctx">The generator syntax context.</param>
    /// <param name="typeDeclaration">The type declaration syntax.</param>
    /// <param name="attribute">The attribute syntax.</param>
    /// <returns>A Target if extraction is successful, otherwise null.</returns>
    private static Target? TryExtractTargetFromAttribute(
        GeneratorSyntaxContext ctx,
        TypeDeclarationSyntax typeDeclaration,
        AttributeSyntax attribute)
    {
        if (!IsGenerateDtoAttribute(attribute))
            return null;

        if (attribute.ArgumentList?.Arguments.Count < 1)
            return null;

        var entitySymbol = ExtractEntityTypeFromAttribute(ctx, attribute);
        if (entitySymbol is null)
            return null;

        var dtoSymbol = ctx.SemanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol;
        if (dtoSymbol is null)
            return null;

        var excludedProperties = ExtractExcludedPropertiesFromAttribute(ctx, attribute);
        var includedProperties = ExtractIncludedPropertiesFromAttribute(ctx, attribute);
        return new Target
        {
            DtoSymbol = dtoSymbol,
            EntitySymbol = entitySymbol,
            ExcludedProperties = excludedProperties,
            IncludedProperties = includedProperties
        };
    }

    /// <summary>
    /// Checks if the attribute is a [GenerateDto] attribute.
    /// </summary>
    /// <param name="attribute">The attribute syntax.</param>
    /// <returns>True if the attribute is [GenerateDto].</returns>
    private static bool IsGenerateDtoAttribute(AttributeSyntax attribute)
    {
        var shortName = ExtractAttributeShortName(attribute);
        return shortName is AttributeShortName or AttributeFullName;
    }

    /// <summary>
    /// Extracts the short name of an attribute (e.g., GenerateDto).
    /// </summary>
    /// <param name="attribute">The attribute syntax.</param>
    /// <returns>The short name, or null if not found.</returns>
    private static string? ExtractAttributeShortName(AttributeSyntax attribute)
    {
        return attribute.Name switch
        {
            IdentifierNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };
    }

    /// <summary>
    /// Extracts the entity type symbol from the [GenerateDto] attribute.
    /// </summary>
    /// <param name="ctx">The generator syntax context.</param>
    /// <param name="attribute">The attribute syntax.</param>
    /// <returns>The entity type symbol, or null if not found.</returns>
    /// <example>
    /// // [GenerateDto(typeof(User))]
    /// </example>
    private static INamedTypeSymbol? ExtractEntityTypeFromAttribute(GeneratorSyntaxContext ctx, AttributeSyntax attribute)
    {
        var firstArg = attribute.ArgumentList!.Arguments[0].Expression;
        
        return firstArg switch
        {
            TypeOfExpressionSyntax typeOfExpression => ExtractEntityFromTypeOfExpression(ctx, typeOfExpression),
            LiteralExpressionSyntax literal when literal.IsKind(SyntaxKind.StringLiteralExpression)
                => ResolveEntityByName(ctx.SemanticModel.Compilation, literal.Token.ValueText),
            _ => null
        };
    }

    /// <summary>
    /// Extracts the entity symbol from a typeof expression.
    /// </summary>
    /// <param name="ctx">The generator syntax context.</param>
    /// <param name="typeOfExpression">The typeof expression syntax.</param>
    /// <returns>The entity type symbol, or null if not found.</returns>
    private static INamedTypeSymbol? ExtractEntityFromTypeOfExpression(GeneratorSyntaxContext ctx, TypeOfExpressionSyntax typeOfExpression)
    {
        var entitySymbol = ctx.SemanticModel.GetTypeInfo(typeOfExpression.Type).Type as INamedTypeSymbol;
        
        // If resolution failed, try by name as fallback
        if (entitySymbol is null || entitySymbol is IErrorTypeSymbol)
        {
            if (typeOfExpression.Type is IdentifierNameSyntax identifierName)
            {
                return ResolveEntityByName(ctx.SemanticModel.Compilation, identifierName.Identifier.Text);
            }
        }
        
        return entitySymbol;
    }

    /// <summary>
    /// Resolves an entity type by its name in the compilation.
    /// </summary>
    /// <param name="compilation">The Roslyn compilation.</param>
    /// <param name="entityName">The entity type name.</param>
    /// <returns>The entity type symbol, or null if not found or ambiguous.</returns>
    private static INamedTypeSymbol? ResolveEntityByName(Compilation compilation, string entityName)
    {
        var matches = FindTypeSymbolsByName(compilation, entityName);
        
        return matches.Count switch
        {
            1 => matches[0],
            > 1 => null, // Ambiguous - skip generation
            _ => null    // Not found
        };
    }

    /// <summary>
    /// Finds all type symbols in the compilation matching the given name.
    /// </summary>
    /// <param name="compilation">The Roslyn compilation.</param>
    /// <param name="typeName">The type name.</param>
    /// <returns>A list of matching type symbols.</returns>
    private static List<INamedTypeSymbol> FindTypeSymbolsByName(Compilation compilation, string typeName)
    {
        return compilation
            .GetSymbolsWithName(name => name.Equals(typeName, StringComparison.Ordinal), SymbolFilter.Type)
            .OfType<INamedTypeSymbol>()
            .Where(symbol => symbol.TypeKind is TypeKind.Class or TypeKind.Struct)
            .ToList();
    }

    /// <summary>
    /// Extracts the set of excluded property names from the [GenerateDto] attribute.
    /// </summary>
    /// <param name="ctx">The generator syntax context.</param>
    /// <param name="attribute">The attribute syntax.</param>
    /// <returns>A set of excluded property names.</returns>
    /// <example>
    /// // [GenerateDto(typeof(User), Exclude = ["Password", nameof(User.Secret)])]
    /// </example>
    private static HashSet<string> ExtractExcludedPropertiesFromAttribute(GeneratorSyntaxContext ctx, AttributeSyntax attribute)
    {
        foreach (var arg in attribute.ArgumentList!.Arguments.Skip(1))
        {
            if (arg.NameEquals?.Name.Identifier.Text == ExcludeParameterName)
            {
                return ExtractExcludedPropertiesFromExpression(ctx, arg.Expression);
            }
        }

        return new HashSet<string>();
    }

    /// <summary>
    /// Extracts the set of included property names from the [GenerateDto] attribute.
    /// </summary>
    /// <param name="ctx">The generator syntax context.</param>
    /// <param name="attribute">The attribute syntax.</param>
    /// <returns>A set of included property names.</returns>
    /// <example>
    /// // [GenerateDto(typeof(User), Include = ["Name", "Email", nameof(User.Phone)])]
    /// </example>
    private static HashSet<string> ExtractIncludedPropertiesFromAttribute(GeneratorSyntaxContext ctx, AttributeSyntax attribute)
    {
        foreach (var arg in attribute.ArgumentList!.Arguments.Skip(1))
        {
            if (arg.NameEquals?.Name.Identifier.Text == IncludeParameterName)
            {
                return ExtractExcludedPropertiesFromExpression(ctx, arg.Expression);
            }
        }

        return new HashSet<string>();
    }

    /// <summary>
    /// Extracts excluded property names from an attribute expression.
    /// </summary>
    /// <param name="ctx">The generator syntax context.</param>
    /// <param name="expression">The expression syntax.</param>
    /// <returns>A set of excluded property names.</returns>
    private static HashSet<string> ExtractExcludedPropertiesFromExpression(GeneratorSyntaxContext ctx, ExpressionSyntax? expression)
    {
        return expression switch
        {
            ImplicitArrayCreationExpressionSyntax implicitArray
                => ExtractStringLiteralsFromInitializer(implicitArray.Initializer),
            ArrayCreationExpressionSyntax { Initializer: not null } explicitArray
                => ExtractStringLiteralsFromInitializer(explicitArray.Initializer),
            CollectionExpressionSyntax collectionExpr
                => ExtractStringLiteralsFromCollectionExpression(ctx, collectionExpr),
            _ => new HashSet<string>()
        };
    }

    /// <summary>
    /// Extracts string literals from an array initializer.
    /// </summary>
    /// <param name="initializer">The initializer expression syntax.</param>
    /// <returns>A set of string literals.</returns>
    private static HashSet<string> ExtractStringLiteralsFromInitializer(InitializerExpressionSyntax initializer)
    {
        var result = new HashSet<string>();
        
        foreach (var expression in initializer.Expressions)
        {
            if (expression is LiteralExpressionSyntax literal && literal.Token.Value is string propertyName)
            {
                result.Add(propertyName);
            }
        }
        
        return result;
    }

    /// <summary>
    /// Extracts string literals from a collection expression (e.g., ["A", nameof(Entity.B)]).
    /// </summary>
    /// <param name="ctx">The generator syntax context.</param>
    /// <param name="collectionExpression">The collection expression syntax.</param>
    /// <returns>A set of string literals.</returns>
    private static HashSet<string> ExtractStringLiteralsFromCollectionExpression(
        GeneratorSyntaxContext ctx,
        CollectionExpressionSyntax collectionExpression)
    {
        var excludedProperties = new HashSet<string>();

        foreach (var element in collectionExpression.Elements)
        {
            if (element is ExpressionElementSyntax { Expression: var expr })
            {
                // Try to get the constant value - this handles both string literals and nameof() expressions
                var constantValue = ctx.SemanticModel.GetConstantValue(expr);
                if (constantValue.HasValue && constantValue.Value is string propertyName)
                {
                    excludedProperties.Add(propertyName);
                }
            }
        }

        return excludedProperties;
    }

    #endregion

    #region DTO Source Generation

    /// <summary>
    /// Generates the DTO source code for a given target and adds it to the compilation.
    /// </summary>
    /// <param name="context">The source production context.</param>
    /// <param name="compilation">The Roslyn compilation.</param>
    /// <param name="target">The DTO generation target.</param>
    /// <param name="globalExclusions">The set of globally excluded property names.</param>
    private static void GenerateDtoSource(SourceProductionContext context, Compilation compilation, Target target, HashSet<string> globalExclusions)
    {
        var dtoMetadata = ExtractDtoMetadata(target);
        var entityProperties = GetEntityProperties(target.EntitySymbol);
        
        // Debug logging: Report property details
        var diagnosticMessage = $"DTO {target.DtoSymbol.Name}: Found {entityProperties.Count} properties from entity {target.EntitySymbol.ToDisplayString()}";
        
        if (entityProperties.Count == 0)
        {
            var diagnostic = new DiagnosticDescriptor(
                id: "DKDTOGEN002",
                title: "No properties found for entity",
                messageFormat: diagnosticMessage + ". This may indicate the entity type wasn't resolved correctly.",
                category: DiagnosticCategory,
                DiagnosticSeverity.Warning,
                isEnabledByDefault: true);
            
            context.ReportDiagnostic(
                Diagnostic.Create(diagnostic, Location.None));
        }
        
        // Validate that Include and Exclude are not both specified
        if (target.IncludedProperties.Count > 0 && target.ExcludedProperties.Count > 0)
        {
            var diagnostic = new DiagnosticDescriptor(
                id: "DKDTOGEN004",
                title: "Include and Exclude are mutually exclusive",
                messageFormat: "DTO {0}: Cannot specify both Include and Exclude properties. Use one or the other.",
                category: DiagnosticCategory,
                DiagnosticSeverity.Warning,
                isEnabledByDefault: true);
            
            context.ReportDiagnostic(
                Diagnostic.Create(diagnostic, Location.None, target.DtoSymbol.Name));
            
            // Skip generation for this DTO
            return;
        }

        // Inform if Include is used with global exclusions (global exclusions are ignored in this case)
        if (target.IncludedProperties.Count > 0 && globalExclusions.Count > 0)
        {
            var diagnostic = new DiagnosticDescriptor(
                id: "DKDTOGEN005",
                title: "Include parameter ignores global exclusions",
                messageFormat: "DTO {0}: Using Include parameter ignores the {1} global exclusion(s). Only specified properties will be included.",
                category: DiagnosticCategory,
                DiagnosticSeverity.Info,
                isEnabledByDefault: true);
            
            context.ReportDiagnostic(
                Diagnostic.Create(diagnostic, Location.None, target.DtoSymbol.Name, globalExclusions.Count));
        }

        var includedProperties = FilterIncludedProperties(entityProperties, target.ExcludedProperties, target.IncludedProperties, globalExclusions);
        
        // Additional logging for property filtering
        if (includedProperties.Count < entityProperties.Count)
        {
            var excludedCount = entityProperties.Count - includedProperties.Count;
            var filterType = target.IncludedProperties.Count > 0 ? "included" : "excluded";
            var propertyList = target.IncludedProperties.Count > 0 
                ? string.Join(", ", target.IncludedProperties)
                : string.Join(", ", target.ExcludedProperties);
            
            var info = new DiagnosticDescriptor(
                id: "DKDTOGEN003",
                title: "Properties filtered from DTO",
                messageFormat: $"DTO {{0}}: {includedProperties.Count} properties {filterType}. {(target.IncludedProperties.Count > 0 ? "Included" : "Excluded")}: {propertyList}",
                category: DiagnosticCategory,
                DiagnosticSeverity.Info,
                isEnabledByDefault: true);
            
            context.ReportDiagnostic(
                Diagnostic.Create(info, Location.None, target.DtoSymbol.Name));
        }
        
        var requiredNamespaces = CollectRequiredNamespaces(includedProperties, dtoMetadata.Namespace);
        var typeDisplayFormat = CreateTypeDisplayFormat();
        var sourceCode = BuildDtoSourceCode(dtoMetadata, includedProperties, requiredNamespaces, typeDisplayFormat);
        
        // Create a unique, stable filename using the full qualified name of the DTO
        var fileName = CreateUniqueFileName(target.DtoSymbol);
        context.AddSource(fileName, sourceCode);
    }

    /// <summary>
    /// Creates a unique file name for the generated DTO source file.
    /// </summary>
    /// <param name="dtoSymbol">The DTO type symbol.</param>
    /// <returns>A unique file name.</returns>
    private static string CreateUniqueFileName(INamedTypeSymbol dtoSymbol)
    {
        // Use just the DTO's simple name for a cleaner filename
        // The namespace scope in the generated code ensures uniqueness
        return $"{dtoSymbol.Name}.g.cs";
    }

    /// <summary>
    /// Extracts metadata for the DTO, including name, namespace, and existing properties.
    /// </summary>
    /// <param name="target">The DTO generation target.</param>
    /// <returns>The DTO metadata.</returns>
    private static DtoMetadata ExtractDtoMetadata(Target target)
    {
        var dtoSymbol = target.DtoSymbol;
        var entitySymbol = target.EntitySymbol;
        
        // Only consider properties that are explicitly defined in the user's source files (not generated)
        // This requires checking the syntax tree location to exclude .g.cs files
        var existingProperties = new HashSet<string>();
        
        foreach (var member in dtoSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            if (!IsFromGeneratedCode(member))
            {
                existingProperties.Add(member.Name);
            }
        }

        var namespaceName = dtoSymbol.ContainingNamespace is { IsGlobalNamespace: false } 
            ? dtoSymbol.ContainingNamespace.ToDisplayString() 
            : null;
        
        var typeKind = DetermineTypeKind(dtoSymbol);
        var entityDisplayName = entitySymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        
        return new DtoMetadata(
            dtoSymbol.Name,
            namespaceName,
            typeKind,
            entityDisplayName,
            existingProperties);
    }
    
    /// <summary>
    /// Determines if a property is from generated code (e.g., .g.cs or obj folder).
    /// </summary>
    /// <param name="property">The property symbol.</param>
    /// <returns>True if the property is from generated code.</returns>
    private static bool IsFromGeneratedCode(IPropertySymbol property)
    {
        // If the property has no syntax references, it's likely from metadata/generated code
        if (property.DeclaringSyntaxReferences.Length == 0)
            return true;
            
        // Check ALL syntax references - if ANY come from generated code, consider it generated
        foreach (var syntaxRef in property.DeclaringSyntaxReferences)
        {
            var filePath = syntaxRef.SyntaxTree.FilePath;
            
            if (IsGeneratedCodePath(filePath))
                return true;
        }
        
        return false;
    }
    
    /// <summary>
    /// Checks if a file path is from generated code (e.g., .g.cs or obj folder).
    /// </summary>
    /// <param name="filePath">The file path.</param>
    /// <returns>True if the file is generated.</returns>
    private static bool IsGeneratedCodePath(string filePath)
    {
        // Check multiple indicators of generated code:
        // 1. Empty file path (can happen with in-memory generated files)
        if (string.IsNullOrEmpty(filePath))
            return true;
            
        // 2. Ends with .g.cs (standard convention for generated files)
        if (filePath.EndsWith(".g.cs", StringComparison.OrdinalIgnoreCase))
            return true;
            
        // 3. Contains intermediate output folder (obj) - use cross-platform approach
        var objFolder = $"{System.IO.Path.DirectorySeparatorChar}obj{System.IO.Path.DirectorySeparatorChar}";
        if (filePath.IndexOf(objFolder, StringComparison.Ordinal) >= 0)
            return true;
            
        // Also check with alternate separator for cross-platform compatibility
        // On Windows, AltDirectorySeparatorChar is '/' while DirectorySeparatorChar is '\'
        // On Unix, both are typically '/', so this check becomes redundant but harmless
        if (System.IO.Path.AltDirectorySeparatorChar != System.IO.Path.DirectorySeparatorChar)
        {
            var altObjFolder = $"{System.IO.Path.AltDirectorySeparatorChar}obj{System.IO.Path.AltDirectorySeparatorChar}";
            if (filePath.IndexOf(altObjFolder, StringComparison.Ordinal) >= 0)
                return true;
        }
            
        return false;
    }

    /// <summary>
    /// Determines the type kind string for the DTO (e.g., "partial class", "partial record").
    /// </summary>
    /// <param name="dtoSymbol">The DTO type symbol.</param>
    /// <returns>The type kind string.</returns>
    private static string DetermineTypeKind(INamedTypeSymbol dtoSymbol)
    {
        if (!dtoSymbol.IsRecord)
            return "partial class";

        return dtoSymbol.TypeKind == TypeKind.Struct
            ? "partial record struct"
            : "partial record";
    }

    #endregion

    #region Property Analysis

    /// <summary>
    /// Gets all public instance properties from the entity, including inherited ones.
    /// </summary>
    /// <param name="entitySymbol">The entity type symbol.</param>
    /// <returns>A list of property symbols.</returns>
    /// <example>
    /// var props = GetEntityProperties(entitySymbol);
    /// </example>
    private static List<IPropertySymbol> GetEntityProperties(INamedTypeSymbol entitySymbol)
    {
        var properties = new List<IPropertySymbol>();
        var seenPropertyNames = new HashSet<string>();

        // Walk up the inheritance chain to collect all properties
        var currentType = entitySymbol;
        while (currentType is not null)
        {
            // Get properties declared on this type level
            var declaredProperties = currentType.GetMembers()
                .OfType<IPropertySymbol>()
                .Where(IsValidEntityProperty);

            // Add properties that haven't been overridden (avoid duplicates)
            foreach (var property in declaredProperties)
            {
                if (seenPropertyNames.Add(property.Name))
                {
                    properties.Add(property);
                }
            }

            // Move to base type
            currentType = currentType.BaseType;

            // Stop at System.Object or System.ValueType
            if (currentType?.SpecialType is SpecialType.System_Object or SpecialType.System_ValueType)
                break;
        }

        return properties;
    }

    /// <summary>
    /// Determines if a property is a valid entity property for DTO generation.
    /// </summary>
    /// <param name="property">The property symbol.</param>
    /// <returns>True if the property is valid.</returns>
    private static bool IsValidEntityProperty(IPropertySymbol property)
    {
        return !property.IsStatic && 
               property.DeclaredAccessibility == Accessibility.Public && 
               property.GetMethod is not null && 
               property.GetMethod.DeclaredAccessibility == Accessibility.Public &&
               property.Parameters.Length == 0;
    }

    /// <summary>
    /// Filters properties based on Include/Exclude lists and global exclusions.
    /// If Include is provided, only those properties are returned (global exclusions are ignored).
    /// Otherwise, properties are filtered by combined global and local Exclude lists.
    /// </summary>
    /// <param name="entityProperties">The entity property list.</param>
    /// <param name="excludedProperties">The set of locally excluded property names.</param>
    /// <param name="includedProperties">The set of included property names.</param>
    /// <param name="globalExclusions">The set of globally excluded property names.</param>
    /// <returns>The filtered list of included properties.</returns>
    private static List<IPropertySymbol> FilterIncludedProperties(
        List<IPropertySymbol> entityProperties,
        HashSet<string> excludedProperties,
        HashSet<string> includedProperties,
        HashSet<string> globalExclusions)
    {
        // If Include is provided, only include those properties (ignores global exclusions)
        if (includedProperties.Count > 0)
        {
            return entityProperties
                .Where(p => includedProperties.Contains(p.Name))
                .ToList();
        }

        // Combine global and local exclusions
        var combinedExcludedProperties = new HashSet<string>(excludedProperties);
        combinedExcludedProperties.UnionWith(globalExclusions);

        // If no exclusions at all, return all properties
        if (combinedExcludedProperties.Count == 0)
            return entityProperties;

        // Exclude properties from the combined exclusion list
        return entityProperties
            .Where(p => !combinedExcludedProperties.Contains(p.Name))
            .ToList();
    }

    /// <summary>
    /// Analyzes a property and returns its metadata for code generation.
    /// </summary>
    /// <param name="property">The property symbol.</param>
    /// <param name="typeFormat">The symbol display format.</param>
    /// <returns>The property info.</returns>
    private static PropertyInfo AnalyzeProperty(IPropertySymbol property, SymbolDisplayFormat typeFormat)
    {
        var typeName = GetPropertyTypeName(property, typeFormat);
        var isNonNullableString = IsNonNullableString(property);
        var isCollection = IsCollectionType(property);
        var isComplexReferenceType = IsComplexReferenceType(property);
        var validationAttributes = ExtractValidationAttributes(property);

        return new PropertyInfo(
            property.Name,
            typeName,
            isNonNullableString,
            isCollection,
            isComplexReferenceType,
            property.NullableAnnotation,
            validationAttributes);
    }

    /// <summary>
    /// Gets the C# type name for a property, handling nullable and generic types.
    /// </summary>
    /// <param name="property">The property symbol.</param>
    /// <param name="typeFormat">The symbol display format.</param>
    /// <returns>The C# type name.</returns>
    private static string GetPropertyTypeName(IPropertySymbol property, SymbolDisplayFormat typeFormat)
    {
        var type = property.Type;

        // Build the complete type name manually to avoid any global:: prefixes
        var typeName = BuildCleanTypeName(type);

        // Ensure nullable reference types have the ? suffix
        if (type.IsReferenceType &&
            property.NullableAnnotation == NullableAnnotation.Annotated &&
            !typeName.EndsWith("?"))
        {
            typeName += "?";
        }

        return typeName;
    }

    /// <summary>
    /// Builds a clean C# type name for a symbol, using keywords for primitives and handling generics.
    /// </summary>
    /// <param name="type">The type symbol.</param>
    /// <returns>The C# type name.</returns>
    private static string BuildCleanTypeName(ITypeSymbol type)
    {
        // Handle special types (int, string, etc.) using C# keywords
        if (type.SpecialType != SpecialType.None)
        {
            return type.SpecialType switch
            {
                SpecialType.System_Object => "object",
                SpecialType.System_Boolean => "bool",
                SpecialType.System_Char => "char",
                SpecialType.System_SByte => "sbyte",
                SpecialType.System_Byte => "byte",
                SpecialType.System_Int16 => "short",
                SpecialType.System_UInt16 => "ushort",
                SpecialType.System_Int32 => "int",
                SpecialType.System_UInt32 => "uint",
                SpecialType.System_Int64 => "long",
                SpecialType.System_UInt64 => "ulong",
                SpecialType.System_Decimal => "decimal",
                SpecialType.System_Single => "float",
                SpecialType.System_Double => "double",
                SpecialType.System_String => "string",
                SpecialType.System_Void => "void",
                _ => type.Name
            };
        }

        // Handle array types
        if (type is IArrayTypeSymbol arrayType)
        {
            var elementTypeName = BuildCleanTypeName(arrayType.ElementType);
            return $"{elementTypeName}[]";
        }

        // Handle nullable value types
        if (type is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T } nullable)
        {
            var underlyingTypeName = BuildCleanTypeName(nullable.TypeArguments[0]);
            return $"{underlyingTypeName}?";
        }

        // Handle generic types (like List<T>, IEnumerable<T>, etc.)
        if (type is INamedTypeSymbol namedType && namedType.TypeArguments.Length > 0)
        {
            var genericName = namedType.Name;
            var typeArgs = string.Join(", ", namedType.TypeArguments.Select(BuildCleanTypeName));
            return $"{genericName}<{typeArgs}>";
        }

        // For non-generic types, just use the simple name (no namespace, no global::)
        return type.Name;
    }

    /// <summary>
    /// Determines if a property is a non-nullable string.
    /// </summary>
    /// <param name="property">The property symbol.</param>
    /// <returns>True if the property is a non-nullable string.</returns>
    private static bool IsNonNullableString(IPropertySymbol property)
    {
        return property.Type.SpecialType == SpecialType.System_String &&
               property.NullableAnnotation != NullableAnnotation.Annotated;
    }

    /// <summary>
    /// Determines if a property is a collection type (array or generic collection).
    /// </summary>
    /// <param name="property">The property symbol.</param>
    /// <returns>True if the property is a collection.</returns>
    private static bool IsCollectionType(IPropertySymbol property)
    {
        if (property.Type is IArrayTypeSymbol)
            return true;

        if (property.Type is not INamedTypeSymbol namedType)
            return false;

        var fullyQualifiedName = namedType.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        return IsKnownCollectionInterface(fullyQualifiedName);
    }

    /// <summary>
    /// Determines if a fully qualified name is a known collection interface.
    /// </summary>
    /// <param name="fullyQualifiedName">The fully qualified type name.</param>
    /// <returns>True if the type is a known collection interface.</returns>
    private static bool IsKnownCollectionInterface(string fullyQualifiedName)
    {
        return fullyQualifiedName.StartsWith("global::System.Collections.Generic.List<") ||
               fullyQualifiedName.StartsWith("global::System.Collections.Generic.IList<") ||
               fullyQualifiedName.StartsWith("global::System.Collections.Generic.ICollection<") ||
               fullyQualifiedName.StartsWith("global::System.Collections.Generic.IEnumerable<");
    }

    /// <summary>
    /// Determines if a property is a non-nullable complex reference type (not string, not collection, not special type).
    /// </summary>
    /// <param name="property">The property symbol.</param>
    /// <returns>True if the property is a non-nullable complex reference type.</returns>
    private static bool IsComplexReferenceType(IPropertySymbol property)
    {
        // Must be a reference type
        if (!property.Type.IsReferenceType)
            return false;

        // Must not be nullable
        if (property.NullableAnnotation == NullableAnnotation.Annotated)
            return false;

        // Exclude strings (they are handled separately with 'required')
        if (property.Type.SpecialType == SpecialType.System_String)
            return false;

        // Exclude collections (they are handled with '= []')
        if (IsCollectionType(property))
            return false;

        // Exclude other special types
        if (property.Type.SpecialType != SpecialType.None)
            return false;

        // This is a complex reference type (e.g., navigation properties, custom classes)
        return true;
    }

    /// <summary>
    /// Extracts validation attributes from a property symbol.
    /// </summary>
    /// <param name="property">The property symbol.</param>
    /// <returns>A list of attribute data for validation attributes.</returns>
    private static List<AttributeData> ExtractValidationAttributes(IPropertySymbol property)
    {
        var validationAttributes = new List<AttributeData>();

        foreach (var attribute in property.GetAttributes())
        {
            if (attribute.AttributeClass is null)
                continue;

            var attributeNamespace = attribute.AttributeClass.ContainingNamespace.ToDisplayString();

            // Check if this is a System.ComponentModel.DataAnnotations attribute
            if (attributeNamespace == "System.ComponentModel.DataAnnotations")
            {
                validationAttributes.Add(attribute);
            }
        }

        return validationAttributes;
    }

    #endregion

    #region Namespace Collection

    /// <summary>
    /// Collects all required namespaces for the DTO properties, excluding the DTO's own namespace.
    /// </summary>
    /// <param name="properties">The list of property symbols.</param>
    /// <param name="dtoNamespace">The DTO's namespace.</param>
    /// <returns>A set of required namespaces.</returns>
    private static HashSet<string> CollectRequiredNamespaces(List<IPropertySymbol> properties, string? dtoNamespace)
    {
        var namespaces = new HashSet<string>();
        
        foreach (var property in properties)
        {
            CollectNamespacesFromType(property.Type, namespaces, dtoNamespace);
            
            // Check if property has validation attributes
            foreach (var attribute in property.GetAttributes())
            {
                if (attribute.AttributeClass is null)
                    continue;

                var attributeNamespace = attribute.AttributeClass.ContainingNamespace.ToDisplayString();
                if (attributeNamespace == "System.ComponentModel.DataAnnotations")
                {
                    namespaces.Add(attributeNamespace);
                    break; // Only need to add the namespace once
                }
            }
        }
        
        return namespaces;
    }

    /// <summary>
    /// Recursively collects namespaces from a type and its generic arguments.
    /// </summary>
    /// <param name="type">The type symbol.</param>
    /// <param name="namespaces">The set of namespaces.</param>
    /// <param name="dtoNamespace">The DTO's namespace.</param>
    private static void CollectNamespacesFromType(ITypeSymbol type, HashSet<string> namespaces, string? dtoNamespace)
    {
        // Skip special types (int, string, etc.)
        if (type.SpecialType != SpecialType.None)
            return;

        // Handle nullable value types
        if (type is INamedTypeSymbol { OriginalDefinition.SpecialType: SpecialType.System_Nullable_T } nullable)
        {
            CollectNamespacesFromType(nullable.TypeArguments[0], namespaces, dtoNamespace);
            return;
        }

        // Add namespace if it's not the DTO's own namespace and not global
        if (type.ContainingNamespace is { IsGlobalNamespace: false } ns)
        {
            var nsString = ns.ToDisplayString();

            // Skip System namespace (except System.Collections.Generic)
            // Always include System.Collections.Generic
            // Always include namespaces different from the DTO's namespace
            if (nsString == "System.Collections.Generic" ||
                (nsString != dtoNamespace && nsString != "System"))
            {
                namespaces.Add(nsString);
            }
        }

        // Recursively handle generic type arguments
        if (type is INamedTypeSymbol namedType)
        {
            foreach (var typeArg in namedType.TypeArguments)
            {
                CollectNamespacesFromType(typeArg, namespaces, dtoNamespace);
            }
        }

        // Handle array element types
        if (type is IArrayTypeSymbol arrayType)
        {
            CollectNamespacesFromType(arrayType.ElementType, namespaces, dtoNamespace);
        }
    }

    /// <summary>
    /// Creates a symbol display format for type names (name only, with generics).
    /// </summary>
    /// <returns>The symbol display format.</returns>
    private static SymbolDisplayFormat CreateTypeDisplayFormat()
    {
        return new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameOnly,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes);
    }

    #endregion

    #region Code Building

    /// <summary>
    /// Builds the complete DTO source code as a string.
    /// </summary>
    /// <param name="metadata">The DTO metadata.</param>
    /// <param name="properties">The list of property symbols.</param>
    /// <param name="namespaces">The set of required namespaces.</param>
    /// <param name="typeFormat">The symbol display format.</param>
    /// <returns>The generated source code.</returns>
    private static string BuildDtoSourceCode(
        DtoMetadata metadata,
        List<IPropertySymbol> properties,
        HashSet<string> namespaces,
        SymbolDisplayFormat typeFormat)
    {
        var builder = new StringBuilder();
        
        AppendFileHeader(builder);
        AppendUsingDirectives(builder, namespaces);
        AppendNamespaceDeclaration(builder, metadata.Namespace);
        AppendDtoClassDeclaration(builder, metadata);
        AppendDtoProperties(builder, properties, metadata.ExistingProperties, typeFormat);
        AppendClassClosing(builder);
        
        return builder.ToString();
    }

    /// <summary>
    /// Appends the file header to the StringBuilder.
    /// </summary>
    /// <param name="builder">The StringBuilder.</param>
    private static void AppendFileHeader(StringBuilder builder)
    {
        builder.AppendLine("// <auto-generated/> Generated by DKNet.EfCore.DtoGenerator");
        builder.AppendLine("#nullable enable");
    }

    /// <summary>
    /// Appends using directives for all required namespaces.
    /// </summary>
    /// <param name="builder">The StringBuilder.</param>
    /// <param name="namespaces">The set of namespaces.</param>
    private static void AppendUsingDirectives(StringBuilder builder, HashSet<string> namespaces)
    {
        if (namespaces.Count == 0)
            return;

        foreach (var namespaceName in namespaces.OrderBy(n => n))
        {
            builder.Append("using ").Append(namespaceName).AppendLine(";");
        }
        
        builder.AppendLine();
    }

    /// <summary>
    /// Appends the namespace declaration if present.
    /// </summary>
    /// <param name="builder">The StringBuilder.</param>
    /// <param name="namespaceName">The namespace name.</param>
    private static void AppendNamespaceDeclaration(StringBuilder builder, string? namespaceName)
    {
        if (namespaceName is not null)
        {
            builder.Append("namespace ").Append(namespaceName).AppendLine(";");
            builder.AppendLine();
        }
    }

    /// <summary>
    /// Appends the DTO class or record declaration.
    /// </summary>
    /// <param name="builder">The StringBuilder.</param>
    /// <param name="metadata">The DTO metadata.</param>
    private static void AppendDtoClassDeclaration(StringBuilder builder, DtoMetadata metadata)
    {
        builder.AppendLine("/// <summary>");
        builder.Append("/// Generated DTO for entity ").Append(metadata.EntityDisplayName).AppendLine(".");
        builder.AppendLine("/// </summary>");
        builder.Append("public ").Append(metadata.TypeKind).Append(' ').AppendLine(metadata.Name);
        builder.AppendLine("{");
    }

    /// <summary>
    /// Appends all DTO properties to the class, skipping existing ones.
    /// </summary>
    /// <param name="builder">The StringBuilder.</param>
    /// <param name="properties">The list of property symbols.</param>
    /// <param name="existingProperties">The set of existing property names.</param>
    /// <param name="typeFormat">The symbol display format.</param>
    private static void AppendDtoProperties(
        StringBuilder builder,
        List<IPropertySymbol> properties,
        HashSet<string> existingProperties,
        SymbolDisplayFormat typeFormat)
    {
        foreach (var property in properties)
        {
            if (existingProperties.Contains(property.Name))
                continue;
                
            var propertyInfo = AnalyzeProperty(property, typeFormat);
            AppendPropertyDeclaration(builder, propertyInfo);
        }
    }

    /// <summary>
    /// Appends a single property declaration to the DTO.
    /// </summary>
    /// <param name="builder">The StringBuilder.</param>
    /// <param name="propertyInfo">The property info.</param>
    private static void AppendPropertyDeclaration(StringBuilder builder, PropertyInfo propertyInfo)
    {
        builder.AppendLine($"    /// <summary>");
        builder.AppendLine($"    /// Gets or sets the {propertyInfo.Name}.");
        builder.AppendLine($"    /// </summary>");
        
        // Append validation attributes
        foreach (var attribute in propertyInfo.ValidationAttributes)
        {
            var attributeString = BuildAttributeString(attribute);
            if (!string.IsNullOrEmpty(attributeString))
            {
                builder.Append("    ").AppendLine(attributeString);
            }
        }
        
        builder.Append("    public ");
        if (propertyInfo.IsNonNullableString)
            builder.Append("required ");
        builder.Append(propertyInfo.TypeName)
               .Append(' ')
               .Append(propertyInfo.Name)
               .Append(" { get; init; }");
        if (propertyInfo.IsCollection && propertyInfo.NullableAnnotation != NullableAnnotation.Annotated)
        {
            builder.Append(" = [];");
        }
        else if (propertyInfo.IsComplexReferenceType)
        {
            builder.Append(" = null!;");
        }
        builder.AppendLine();
    }

    /// <summary>
    /// Appends the closing brace for the class or record.
    /// </summary>
    /// <param name="builder">The StringBuilder.</param>
    private static void AppendClassClosing(StringBuilder builder)
    {
        builder.AppendLine("}");
    }

    /// <summary>
    /// Builds an attribute string from AttributeData.
    /// </summary>
    /// <param name="attribute">The attribute data.</param>
    /// <returns>The attribute string, or null if it cannot be built.</returns>
    private static string? BuildAttributeString(AttributeData attribute)
    {
        if (attribute.AttributeClass is null)
            return null;

        var attributeName = attribute.AttributeClass.Name;
        
        // Remove "Attribute" suffix if present
        if (attributeName.EndsWith("Attribute"))
        {
            attributeName = attributeName.Substring(0, attributeName.Length - "Attribute".Length);
        }

        var builder = new StringBuilder();
        builder.Append('[').Append(attributeName);

        // Check if we need to add arguments (constructor or named)
        bool hasArguments = attribute.ConstructorArguments.Length > 0 || attribute.NamedArguments.Length > 0;
        
        if (hasArguments)
        {
            builder.Append('(');
            
            // Add constructor arguments
            for (int i = 0; i < attribute.ConstructorArguments.Length; i++)
            {
                if (i > 0)
                    builder.Append(", ");

                var arg = attribute.ConstructorArguments[i];
                builder.Append(FormatAttributeArgument(arg));
            }

            // Add named arguments
            if (attribute.NamedArguments.Length > 0)
            {
                if (attribute.ConstructorArguments.Length > 0)
                    builder.Append(", ");

                for (int i = 0; i < attribute.NamedArguments.Length; i++)
                {
                    if (i > 0)
                        builder.Append(", ");

                    var namedArg = attribute.NamedArguments[i];
                    builder.Append(namedArg.Key)
                           .Append(" = ")
                           .Append(FormatAttributeArgument(namedArg.Value));
                }
            }
            
            builder.Append(')');
        }

        builder.Append(']');
        return builder.ToString();
    }

    /// <summary>
    /// Formats an attribute argument value for code generation.
    /// </summary>
    /// <param name="arg">The typed constant argument.</param>
    /// <returns>The formatted argument string.</returns>
    private static string FormatAttributeArgument(TypedConstant arg)
    {
        if (arg.IsNull)
            return "null";

        if (arg.Kind == TypedConstantKind.Array)
        {
            var arrayBuilder = new StringBuilder();
            arrayBuilder.Append("new[] { ");
            
            for (int i = 0; i < arg.Values.Length; i++)
            {
                if (i > 0)
                    arrayBuilder.Append(", ");
                arrayBuilder.Append(FormatAttributeArgument(arg.Values[i]));
            }
            
            arrayBuilder.Append(" }");
            return arrayBuilder.ToString();
        }

        if (arg.Type?.TypeKind == TypeKind.Enum)
        {
            // Format enum values
            var enumTypeName = arg.Type.Name;
            return $"{enumTypeName}.{arg.Value}";
        }

        if (arg.Value is string stringValue)
        {
            // Escape string literals
            return $"\"{stringValue.Replace("\"", "\\\"")}\"";
        }

        if (arg.Value is bool boolValue)
        {
            return boolValue ? "true" : "false";
        }

        if (arg.Value is char charValue)
        {
            return $"'{charValue}'";
        }

        if (arg.Type?.SpecialType == SpecialType.System_Object && arg.Value != null)
        {
            // Type argument (typeof)
            if (arg.Value is ITypeSymbol typeSymbol)
            {
                return $"typeof({typeSymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)})";
            }
        }

        // Default: ToString
        return arg.Value?.ToString() ?? "null";
    }

    /// <summary>
    /// Creates a valid parameter name from a property name, escaping C# keywords.
    /// </summary>
    /// <param name="propertyName">The property name.</param>
    /// <returns>The parameter name.</returns>
    private static string CreateParameterName(string propertyName)
    {
        if (string.IsNullOrEmpty(propertyName))
            return propertyName;

        var paramName = char.ToLowerInvariant(propertyName[0]) + propertyName.Substring(1);
        
        // Escape C# keywords
        if (SyntaxFacts.GetKeywordKind(paramName) != SyntaxKind.None)
            paramName = "@" + paramName;
            
        return paramName;
    }

    /// <summary>
    /// Reports a generation error as a diagnostic warning.
    /// </summary>
    /// <param name="context">The source production context.</param>
    /// <param name="dtoSymbol">The DTO type symbol.</param>
    /// <param name="message">The error message.</param>
    private static void ReportGenerationError(SourceProductionContext context, INamedTypeSymbol dtoSymbol, string message)
    {
        var descriptor = new DiagnosticDescriptor(
            id: DiagnosticId,
            title: "DTO generation warning",
            messageFormat: "{0}: {1}",
            category: DiagnosticCategory,
            DiagnosticSeverity.Warning,
            isEnabledByDefault: true);

        context.ReportDiagnostic(
            Diagnostic.Create(descriptor, Location.None, dtoSymbol.ToDisplayString(), message));
    }

    #endregion

    #region Data Models

    /// <summary>
    /// Represents a DTO generation target (DTO type, entity type, and excluded/included properties).
    /// </summary>
    private sealed record Target
    {
        public INamedTypeSymbol DtoSymbol { get; set; } = null!;
        public INamedTypeSymbol EntitySymbol { get; set; } = null!;
        public HashSet<string> ExcludedProperties { get; set; } = new();
        public HashSet<string> IncludedProperties { get; set; } = new();

        // Use string-based comparison for stability across compilations
        // SymbolEqualityComparer can give inconsistent results with incremental compilation
        public bool Equals(Target? other)
        {
            if (other is null) return false;
            if (ReferenceEquals(this, other)) return true;

            // Compare using ToDisplayString for stable comparison across compilations
            var dtoName1 = DtoSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var dtoName2 = other.DtoSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (dtoName1 != dtoName2)
                return false;

            var entityName1 = EntitySymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var entityName2 = other.EntitySymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (entityName1 != entityName2)
                return false;

            // Compare excluded properties count and content
            if (ExcludedProperties.Count != other.ExcludedProperties.Count)
                return false;

            if (!ExcludedProperties.SetEquals(other.ExcludedProperties))
                return false;

            // Compare included properties count and content
            if (IncludedProperties.Count != other.IncludedProperties.Count)
                return false;

            return IncludedProperties.SetEquals(other.IncludedProperties);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                int hash = 17;
                
                // Use string-based hash for stability
                var dtoName = DtoSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var entityName = EntitySymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                
                hash = hash * 31 + StringComparer.Ordinal.GetHashCode(dtoName);
                hash = hash * 31 + StringComparer.Ordinal.GetHashCode(entityName);

                // Hash excluded properties in a stable order
                foreach (var prop in ExcludedProperties.OrderBy(p => p, StringComparer.Ordinal))
                {
                    hash = hash * 31 + StringComparer.Ordinal.GetHashCode(prop);
                }

                // Hash included properties in a stable order
                foreach (var prop in IncludedProperties.OrderBy(p => p, StringComparer.Ordinal))
                {
                    hash = hash * 31 + StringComparer.Ordinal.GetHashCode(prop);
                }

                return hash;
            }
        }
    }

    /// <summary>
    /// Metadata for a DTO, including name, namespace, type kind, and existing properties.
    /// </summary>
    private sealed class DtoMetadata
    {
        public string Name { get; }
        public string? Namespace { get; }
        public string TypeKind { get; }
        public string EntityDisplayName { get; }
        public HashSet<string> ExistingProperties { get; }

        public DtoMetadata(
            string name,
            string? namespaceName,
            string typeKind,
            string entityDisplayName,
            HashSet<string> existingProperties)
        {
            Name = name;
            Namespace = namespaceName;
            TypeKind = typeKind;
            EntityDisplayName = entityDisplayName;
            ExistingProperties = existingProperties;
        }
    }

    /// <summary>
    /// Metadata for a property to be generated in the DTO.
    /// </summary>
    private sealed class PropertyInfo
    {
        public string Name { get; }
        public string TypeName { get; }
        public bool IsNonNullableString { get; }
        public bool IsCollection { get; }
        public bool IsComplexReferenceType { get; }
        public NullableAnnotation NullableAnnotation { get; }
        public List<AttributeData> ValidationAttributes { get; }

        public PropertyInfo(
            string name,
            string typeName,
            bool isNonNullableString,
            bool isCollection,
            bool isComplexReferenceType,
            NullableAnnotation nullableAnnotation,
            List<AttributeData> validationAttributes)
        {
            Name = name;
            TypeName = typeName;
            IsNonNullableString = isNonNullableString;
            IsCollection = isCollection;
            IsComplexReferenceType = isComplexReferenceType;
            NullableAnnotation = nullableAnnotation;
            ValidationAttributes = validationAttributes;
        }
    }

    #endregion
}
