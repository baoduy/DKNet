// <auto-generated/> Public attribute & source generator implementation for DKNet.EfCore.DtoGenerator.
// Consumers reference this project/package as an Analyzer. Keep logic cohesive here.

#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DKNet.EfCore.DtoGenerator;

/// <summary>
/// Attribute applied to an empty <c>partial record</c> (recommended) or class to instruct the DTO generator
/// to emit properties mirroring the public instance readable properties of the provided entity <see cref="Type"/>.
/// </summary>
/// <remarks>
/// Example:
/// <code>
/// public class Person { public Guid ID { get; set; } public string Name { get; set; } = string.Empty; }
/// [GenerateDto(typeof(Person))]
/// public partial record PersonDto; // Generated properties + mapping helpers.
///
/// // Exclude specific properties:
/// [GenerateDto(typeof(Person), Exclude = new[] { "ID", "CreatedAt" })]
/// public partial record PersonSummaryDto; // Generated without ID and CreatedAt properties.
/// </code>
/// </remarks>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
public sealed class GenerateDtoAttribute : Attribute
{
    public Type EntityType { get; }

    /// <summary>
    /// Gets or sets the names of properties to exclude from DTO generation.
    /// </summary>
    public string[]? Exclude { get; set; }

    public GenerateDtoAttribute(Type entityType) => EntityType = entityType;
}

/// <summary>
/// Incremental source generator for DTOs. Generates properties (init-only) for each public instance
/// readable property of the entity (adds 'required' for non-nullable reference types).
/// No mapping helper methods are generated (entity to DTO mapping can be handled externally e.g. via Mapster Adapt).
/// </summary>
[Generator]
[System.Diagnostics.CodeAnalysis.SuppressMessage("MicrosoftCodeAnalysisCorrectness", "RS1041:This compiler extension should not be implemented in an assembly with target framework", Justification = "Targeting .NET 9+ only")]
public sealed class DtoGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var targets = context.SyntaxProvider.CreateSyntaxProvider(
                static (node, _) => node is TypeDeclarationSyntax t && t.AttributeLists.Count > 0,
                static (ctx, _) => GetTarget(ctx))
            .Where(static t => t is not null)!;

        var combo = context.CompilationProvider.Combine(targets.Collect());

        context.RegisterSourceOutput(combo, static (spc, pair) =>
        {
            var (compilation, collected) = pair;
            foreach (var target in collected)
            {
                if (target is null) continue;
                try
                {
                    EmitForTarget(spc, compilation, target);
                }
                catch (Exception ex)
                {
                    ReportDiagnostic(spc, target.DtoSymbol, ex.Message);
                }
            }
        });
    }

    private static Target? GetTarget(GeneratorSyntaxContext ctx)
    {
        if (ctx.Node is not TypeDeclarationSyntax tds) return null;
        foreach (var list in tds.AttributeLists)
        {
            foreach (var attr in list.Attributes)
            {
                var shortName = attr.Name switch
                {
                    IdentifierNameSyntax ins => ins.Identifier.Text,
                    QualifiedNameSyntax qns => qns.Right.Identifier.Text,
                    _ => null
                };
                if (shortName is not ("GenerateDto" or "GenerateDtoAttribute")) continue;
                if (attr.ArgumentList?.Arguments.Count < 1) return null;
                if (attr.ArgumentList!.Arguments[0].Expression is not TypeOfExpressionSyntax toe) return null;
                var entitySymbol = ctx.SemanticModel.GetTypeInfo(toe.Type).Type as INamedTypeSymbol;
                if (entitySymbol is null) return null;
                var dtoSymbol = ctx.SemanticModel.GetDeclaredSymbol(tds) as INamedTypeSymbol;
                if (dtoSymbol is null) return null;

                // Extract Exclude parameter if present
                HashSet<string>? excludedProperties = null;
                foreach (var arg in attr.ArgumentList.Arguments)
                {
                    if (arg.NameEquals?.Name.Identifier.Text == "Exclude")
                    {
                        if (arg.Expression is ImplicitArrayCreationExpressionSyntax implicitArray)
                        {
                            excludedProperties = ExtractStringLiterals(implicitArray.Initializer);
                        }
                        else if (arg.Expression is ArrayCreationExpressionSyntax explicitArray && explicitArray.Initializer is not null)
                        {
                            excludedProperties = ExtractStringLiterals(explicitArray.Initializer);
                        }
                        else if (arg.Expression is CollectionExpressionSyntax collectionExpr)
                        {
                            excludedProperties = new HashSet<string>();
                            foreach (var element in collectionExpr.Elements)
                            {
                                if (element is ExpressionElementSyntax exprElement &&
                                    exprElement.Expression is LiteralExpressionSyntax literal &&
                                    ctx.SemanticModel.GetConstantValue(literal).Value is string str)
                                {
                                    excludedProperties.Add(str);
                                }
                            }
                        }
                    }
                }

                return new Target(dtoSymbol, entitySymbol, excludedProperties);
            }
        }
        return null;
    }

    private static HashSet<string> ExtractStringLiterals(InitializerExpressionSyntax initializer)
    {
        var result = new HashSet<string>();
        foreach (var expr in initializer.Expressions)
        {
            if (expr is LiteralExpressionSyntax literal && literal.Token.Value is string str)
            {
                result.Add(str);
            }
        }
        return result;
    }

    private static void EmitForTarget(SourceProductionContext context, Compilation compilation, Target target)
    {
        var dtoSymbol = target.DtoSymbol;
        var entitySymbol = target.EntitySymbol;
        var entityMinimal = entitySymbol.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);

        var entityProps = entitySymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public && p.GetMethod is not null && p.Parameters.Length == 0)
            .OrderBy(p => p.Name)
            .ToList();

        var existingDtoProps = new HashSet<string>(dtoSymbol.GetMembers().OfType<IPropertySymbol>().Select(p => p.Name));

        var ns = dtoSymbol.ContainingNamespace is { IsGlobalNamespace: false } ? dtoSymbol.ContainingNamespace.ToDisplayString() : null;
        var dtoName = dtoSymbol.Name;

        // Custom format that includes nullable annotations
        var typeDisplayFormat = new SymbolDisplayFormat(
            globalNamespaceStyle: SymbolDisplayGlobalNamespaceStyle.Included,
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters,
            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.UseSpecialTypes |
                                  SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/> Generated by DKNet.EfCore.DtoGenerator");
        sb.AppendLine("#nullable enable");
        if (ns is not null)
        {
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();
        }
        var typeKind = dtoSymbol.IsRecord
            ? (dtoSymbol.TypeKind == TypeKind.Struct ? "partial record struct" : "partial record")
            : "partial class";

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Generated DTO for entity {entityMinimal}.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public {typeKind} {dtoName}");
        sb.AppendLine("{");

        foreach (var p in entityProps)
        {
            // Skip if property is in user's existing DTO or in the Exclude list
            if (existingDtoProps.Contains(p.Name)) continue;
            if (target.ExcludedProperties?.Contains(p.Name) == true) continue;

            var typeName = p.Type.ToDisplayString(typeDisplayFormat);

            // Manually append ? for nullable reference types since SymbolDisplayFormat doesn't always work
            if (p.Type.IsReferenceType && p.NullableAnnotation == NullableAnnotation.Annotated && !typeName.EndsWith("?"))
            {
                typeName += "?";
            }

            // Only add 'required' to non-nullable string properties
            var isNonNullableString = p.Type.SpecialType == SpecialType.System_String &&
                                      p.NullableAnnotation != NullableAnnotation.Annotated;

            // Check if property is a collection type using more robust metadata name check
            var isCollection = false;
            if (p.Type is IArrayTypeSymbol)
            {
                isCollection = true;
            }
            else if (p.Type is INamedTypeSymbol namedType)
            {
                var fullName = namedType.OriginalDefinition.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                isCollection = fullName.StartsWith("global::System.Collections.Generic.List<") ||
                              fullName.StartsWith("global::System.Collections.Generic.IList<") ||
                              fullName.StartsWith("global::System.Collections.Generic.ICollection<") ||
                              fullName.StartsWith("global::System.Collections.Generic.IEnumerable<");
            }

            sb.Append("    /// <summary>Gets the value mapped from entity property ").Append(p.Name).AppendLine(".</summary>");
            sb.Append("    public ");
            if (isNonNullableString) sb.Append("required ");
            sb.Append(typeName).Append(' ').Append(p.Name).Append(" { get; init; }");
            if (isCollection && p.NullableAnnotation != NullableAnnotation.Annotated)
            {
                sb.Append(" = [];");
            }
            sb.AppendLine();
        }
        sb.AppendLine("}");
        context.AddSource(dtoName + ".cs", sb.ToString());
    }

    private static void ReportDiagnostic(SourceProductionContext context, INamedTypeSymbol dtoSymbol, string message)
    {
        var descriptor = new DiagnosticDescriptor(
            id: "DKDTOGEN001",
            title: "DTO generation warning",
            messageFormat: "{0}: {1}",
            category: "DKNet.EfCore.DtoGenerator",
            DiagnosticSeverity.Warning,
            isEnabledByDefault: true);
        context.ReportDiagnostic(Diagnostic.Create(descriptor, Location.None, dtoSymbol.ToDisplayString(), message));
    }

    private sealed class Target
    {
        public INamedTypeSymbol DtoSymbol { get; }
        public INamedTypeSymbol EntitySymbol { get; }
        public HashSet<string>? ExcludedProperties { get; }

        public Target(INamedTypeSymbol dtoSymbol, INamedTypeSymbol entitySymbol, HashSet<string>? excludedProperties = null)
        {
            DtoSymbol = dtoSymbol;
            EntitySymbol = entitySymbol;
            ExcludedProperties = excludedProperties;
        }
    }
}
