using System.Security.Cryptography;
using System.Text;

namespace DKNet.Svc.Encryption;

public interface IPasswordAesEncryption
{
    string Encrypt(string plainText, string password, int iterations = 100_000);
    string Decrypt(string cipherPackage, string password, int iterations = 100_000);
}

/// <summary>
/// Password-based AES encryption using PBKDF2 for key derivation and AES-CBC for encryption.
/// Output format (all Base64, then whole string Base64 wrapped): salt:iv:cipher
/// </summary>
public sealed class PasswordAesEncryption : IPasswordAesEncryption
{
    private const int SaltSize = 16; // 128-bit salt
    private const int KeySize = 32; // 256-bit key

    public string Encrypt(string plainText, string password, int iterations = 100_000)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(password);
        ArgumentNullException.ThrowIfNull(plainText);
        var salt = RandomNumberGenerator.GetBytes(SaltSize);
        var key = DeriveKey(password, salt, iterations);
        using var aes = Aes.Create();
        aes.KeySize = 256;
        aes.Key = key;
        aes.GenerateIV();
        using var enc = aes.CreateEncryptor();
        using var ms = new MemoryStream();
        using (var cs = new CryptoStream(ms, enc, CryptoStreamMode.Write))
        using (var sw = new StreamWriter(cs, Encoding.UTF8))
        {
            sw.Write(plainText);
        }

        var cipher = ms.ToArray();
        var packaged =
            $"{Convert.ToBase64String(salt)}:{Convert.ToBase64String(aes.IV)}:{Convert.ToBase64String(cipher)}";
        return packaged.ToBase64String();
    }

    public string Decrypt(string cipherPackage, string password, int iterations = 100_000)
    {
        ArgumentException.ThrowIfNullOrWhiteSpace(password);
        ArgumentException.ThrowIfNullOrWhiteSpace(cipherPackage);
        var decoded = cipherPackage.FromBase64String();
        var parts = decoded.Split(':');
        if (parts.Length != 3) throw new ArgumentException("Invalid cipher package format", nameof(cipherPackage));
        var salt = Convert.FromBase64String(parts[0]);
        var iv = Convert.FromBase64String(parts[1]);
        var cipher = Convert.FromBase64String(parts[2]);
        var key = DeriveKey(password, salt, iterations);
        using var aes = Aes.Create();
        aes.Key = key;
        aes.IV = iv;
        using var dec = aes.CreateDecryptor();
        using var ms = new MemoryStream(cipher);
        using var cs = new CryptoStream(ms, dec, CryptoStreamMode.Read);
        using var sr = new StreamReader(cs, Encoding.UTF8);
        return sr.ReadToEnd();
    }

    private static byte[] DeriveKey(string password, byte[] salt, int iterations)
    {
        using var pbkdf2 = new Rfc2898DeriveBytes(password, salt, iterations, HashAlgorithmName.SHA256);
        return pbkdf2.GetBytes(KeySize);
    }
}